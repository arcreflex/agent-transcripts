/**
 * Claude Code JSONL adapter.
 *
 * Parses session files from ~/.claude/projects/{project}/sessions/{session}.jsonl
 */

import { Glob } from "bun";
import { basename, join, relative } from "path";
import { homedir } from "os";
import { stat } from "fs/promises";
import type {
  Adapter,
  DiscoveredSession,
  Transcript,
  Message,
  Warning,
  ToolCall,
} from "../types.ts";
import { extractToolSummary } from "../utils/summary.ts";

// ============================================================================
// sessions-index.json types
// ============================================================================

/**
 * Root structure of sessions-index.json file.
 * Contains metadata about all Claude Code sessions for a project.
 */
interface SessionsIndex {
  /** Schema version for the index file format */
  version: number;
  /** Array of session metadata entries */
  entries: SessionIndexEntry[];
  /**
   * Original project path (workspace path).
   * This is the actual project directory being worked on.
   */
  originalPath: string;
}

/**
 * Metadata for a single Claude Code session.
 * Each entry corresponds to one .jsonl session file.
 */
interface SessionIndexEntry {
  /** Unique session identifier (UUID format) */
  sessionId: string;
  /**
   * Absolute path to the session .jsonl file.
   * Typically in ~/.claude/projects/<project-name>/<sessionId>.jsonl
   */
  fullPath: string;
  /**
   * File modification time in Unix epoch milliseconds.
   * Used to detect file changes and for sorting.
   */
  fileMtime: number;
  /**
   * First user prompt in the session (may be truncated with "…").
   * Will be "No prompt" for empty sessions or "[Request interrupted by user]"
   * for sessions that were interrupted before completion.
   */
  firstPrompt: string;
  /**
   * Human-readable summary of the session.
   * Generated by Claude Code, describes what the session accomplished.
   * Common patterns:
   * - "Conversation Cleared" / "Empty Conversation - Clear Command Only" for cleared sessions
   * - Action-oriented descriptions for active sessions
   */
  summary: string;
  /** Total number of messages in the session */
  messageCount: number;
  /** ISO 8601 timestamp when the session was created */
  created: string;
  /** ISO 8601 timestamp when the session was last modified */
  modified: string;
  /**
   * Git branch that was active when the session was created/active.
   * Useful for correlating sessions with code changes.
   */
  gitBranch: string;
  /**
   * Project workspace path.
   * This is the working directory for the session.
   */
  projectPath: string;
  /**
   * Whether this session is a "sidechain" (subagent) session.
   * Subagent sessions are spawned by parent sessions for specialized tasks.
   * Main sessions have isSidechain: false.
   */
  isSidechain: boolean;
}

// ============================================================================
// JSONL record types
// ============================================================================

/**
 * Top-level JSONL record type discriminated by `type` field.
 * Each line in a Claude Code session .jsonl file is one of these record types.
 */
type ClaudeRecord =
  | FileHistorySnapshot
  | UserRecord
  | AssistantRecord
  | SystemRecord
  | ProgressRecord
  | SummaryRecord;

/**
 * Records that participate in the message tree (have uuid, parentUuid, timestamp).
 * These are the record types that the parsing code processes for transcript generation.
 */
type MessageRecord =
  | UserRecord
  | AssistantRecord
  | SystemRecord
  | ProgressRecord;

/** Type guard for message records */
function isMessageRecord(rec: ClaudeRecord): rec is MessageRecord {
  return (
    rec.type === "user" ||
    rec.type === "assistant" ||
    rec.type === "system" ||
    rec.type === "progress"
  );
}

/** Common fields shared by most record types */
interface BaseRecord {
  uuid: string;
  parentUuid: string | null;
  timestamp: string;
  isSidechain: boolean;
  userType: "external";
  cwd: string;
  sessionId: string;
  version: string;
  gitBranch: string;
  slug?: string;
}

interface FileHistorySnapshot {
  type: "file-history-snapshot";
  messageId: string;
  snapshot: {
    messageId: string;
    trackedFileBackups: Record<
      string,
      {
        backupFileName: string;
        version: number;
        backupTime: string;
      }
    >;
    timestamp: string;
  };
  isSnapshotUpdate: boolean;
}

interface UserRecord extends BaseRecord {
  type: "user";
  message: {
    role: "user";
    content: string | ContentBlock[];
  };
  /** Present when message is metadata (e.g., command caveats) */
  isMeta?: boolean;
  /** Present when message is a tool result */
  toolUseResult?: {
    task?: {
      id: string;
      subject: string;
    };
    [key: string]: unknown;
  };
  /** UUID of the assistant message that triggered this tool use */
  sourceToolAssistantUUID?: string;
}

interface AssistantRecord extends BaseRecord {
  type: "assistant";
  message: {
    model: string;
    id: string;
    type: "message";
    role: "assistant";
    content: ContentBlock[];
    stop_reason: string | null;
    stop_sequence: string | null;
    usage: {
      input_tokens: number;
      cache_creation_input_tokens?: number;
      cache_read_input_tokens?: number;
      cache_creation?: {
        ephemeral_5m_input_tokens: number;
        ephemeral_1h_input_tokens: number;
      };
      output_tokens: number;
      service_tier?: string;
    };
  };
  requestId: string;
}

interface SystemRecord extends BaseRecord {
  type: "system";
  /** Subtypes: "turn_duration", etc. */
  subtype: string;
  isMeta: boolean;
  /** Present for turn_duration subtype */
  durationMs?: number;
  /** Text content (if any) - some system messages may include display text */
  content?: string;
}

interface ProgressRecord extends BaseRecord {
  type: "progress";
  data: AgentProgressData | HookProgressData;
  /** Tool use ID that triggered this progress */
  toolUseID?: string;
  /** Parent tool use ID (for nested tool calls) */
  parentToolUseID?: string;
}

interface AgentProgressData {
  type: "agent_progress";
  message: {
    type: "user";
    message: {
      role: "user";
      content: ContentBlock[];
    };
    uuid: string;
    timestamp: string;
  };
  normalizedMessages: unknown[];
  /** The prompt text sent to the agent */
  prompt: string;
  /** Agent identifier */
  agentId: string;
}

interface HookProgressData {
  type: "hook_progress";
  hookEvent: string;
  hookName: string;
  command: string;
}

interface SummaryRecord {
  type: "summary";
  /** Human-readable summary text */
  summary: string;
  /** UUID of the leaf message in the conversation tree */
  leafUuid: string;
}

// ============================================================================
// Content block types
// ============================================================================

/**
 * Content blocks appear in message.content arrays for both user and assistant messages.
 */
type ContentBlock = TextBlock | ThinkingBlock | ToolUseBlock | ToolResultBlock;

interface TextBlock {
  type: "text";
  text: string;
}

interface ThinkingBlock {
  type: "thinking";
  thinking: string;
}

interface ToolUseBlock {
  type: "tool_use";
  id: string;
  name: string;
  input: Record<string, unknown>;
}

interface ToolResultBlock {
  type: "tool_result";
  tool_use_id: string;
  content: string | ContentBlock[];
  /** Present when tool result indicates an error */
  is_error?: boolean;
}

/**
 * Parse JSONL content with best-effort error recovery.
 */
function parseJsonl(content: string): {
  records: ClaudeRecord[];
  warnings: Warning[];
} {
  const records: ClaudeRecord[] = [];
  const warnings: Warning[] = [];
  const lines = content.split("\n");

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;

    try {
      const record = JSON.parse(line) as ClaudeRecord;
      records.push(record);
    } catch (e) {
      warnings.push({
        type: "parse_error",
        detail: `Line ${i + 1}: ${e instanceof Error ? e.message : "Invalid JSON"}`,
      });
    }
  }

  return { records, warnings };
}

/** Any record that can participate in parent-child relationships */
type TraversableRecord = { uuid: string; parentUuid: string | null };

/**
 * Find the nearest message ancestor by walking up the parent chain.
 * Returns undefined if no message ancestor exists.
 */
function findMessageAncestor(
  parentUuid: string | null | undefined,
  allByUuid: Map<string, TraversableRecord>,
  messageUuids: Set<string>,
): string | undefined {
  const visited = new Set<string>();
  let current = parentUuid;
  while (current) {
    if (visited.has(current)) {
      return undefined; // Cycle detected
    }
    visited.add(current);
    if (messageUuids.has(current)) {
      return current;
    }
    const rec = allByUuid.get(current);
    current = rec?.parentUuid ?? null;
  }
  return undefined;
}

/** Message record types that appear in conversation trees */
type ConversationRecord = UserRecord | AssistantRecord | SystemRecord;

/** Result of splitting records into conversation trees */
interface SplitResult {
  conversations: ConversationRecord[][];
  /** Map from message UUID to its resolved parent (nearest message ancestor) */
  resolvedParents: Map<string, string | undefined>;
}

/**
 * Build message graph and find conversation boundaries.
 * Returns conversations and a map of resolved parent references.
 */
function splitConversations(records: ClaudeRecord[]): SplitResult {
  // Filter to only message records (user, assistant, system - records with uuid)
  const messageRecords = records.filter(
    (r): r is UserRecord | AssistantRecord | SystemRecord =>
      r.type === "user" || r.type === "assistant" || r.type === "system",
  );

  if (messageRecords.length === 0) {
    return { conversations: [], resolvedParents: new Map() };
  }

  // Build UUID lookup for ALL records with uuid/parentUuid to enable
  // traversing through non-message records (e.g., progress) when resolving parents
  const allByUuid = new Map<string, TraversableRecord>();
  for (const rec of records) {
    if (isMessageRecord(rec)) {
      allByUuid.set(rec.uuid, rec);
    }
  }

  // Set of message UUIDs for quick lookup
  const messageUuids = new Set<string>(messageRecords.map((r) => r.uuid));

  // Build parent → children map, resolving through non-message records
  // Also track resolved parents for use in transformation
  const byUuid = new Map<string, ConversationRecord>();
  const children = new Map<string, string[]>();
  const resolvedParents = new Map<string, string | undefined>();
  const roots: string[] = [];

  for (const rec of messageRecords) {
    byUuid.set(rec.uuid, rec);

    // Find nearest message ancestor (walking through non-message records)
    const ancestor = findMessageAncestor(
      rec.parentUuid,
      allByUuid,
      messageUuids,
    );

    // Store resolved parent for this message
    resolvedParents.set(rec.uuid, ancestor);

    if (ancestor) {
      const existing = children.get(ancestor) || [];
      existing.push(rec.uuid);
      children.set(ancestor, existing);
    } else {
      // No message ancestor - this is a root
      roots.push(rec.uuid);
    }
  }

  // BFS from each root to collect conversation
  const visited = new Set<string>();
  const conversations: ConversationRecord[][] = [];

  for (const root of roots) {
    if (visited.has(root)) continue;

    const conversation: ConversationRecord[] = [];
    const queue = [root];

    while (queue.length > 0) {
      const uuid = queue.shift();
      if (!uuid || visited.has(uuid)) continue;
      visited.add(uuid);

      const rec = byUuid.get(uuid);
      if (rec) conversation.push(rec);

      // Add children to queue
      const childUuids = children.get(uuid) || [];
      queue.push(...childUuids);
    }

    // Note: we don't sort here - renderer handles ordering via tree traversal
    if (conversation.length > 0) {
      conversations.push(conversation);
    }
  }

  // Sort conversations by their first message timestamp
  conversations.sort((a, b) => {
    const ta = new Date(a[0].timestamp).getTime();
    const tb = new Date(b[0].timestamp).getTime();
    return ta - tb;
  });

  return { conversations, resolvedParents };
}

/**
 * Extract text content from message content blocks.
 */
function extractText(content: string | ContentBlock[]): string {
  if (typeof content === "string") return content;

  return content
    .flatMap((b) => (b.type === "text" && b.text ? [b.text] : []))
    .join("\n");
}

/**
 * Extract thinking from content blocks.
 */
function extractThinking(content: string | ContentBlock[]): string | undefined {
  if (typeof content === "string") return undefined;

  const thinking = content
    .flatMap((b) => (b.type === "thinking" && b.thinking ? [b.thinking] : []))
    .join("\n\n");

  return thinking || undefined;
}

/**
 * Extract tool calls from content blocks.
 * Matches with results from the toolResults map.
 */
function extractToolCalls(
  content: string | ContentBlock[],
  toolResults: Map<string, string>,
): ToolCall[] {
  if (typeof content === "string") return [];

  return content.flatMap((b) => {
    if (b.type === "tool_use" && b.name && b.id) {
      const result = toolResults.get(b.id);
      return [
        {
          id: b.id,
          name: b.name,
          summary: extractToolSummary(b.name, b.input || {}),
          input: b.input,
          result,
        },
      ];
    }
    return [];
  });
}

/**
 * Safely convert tool result content to string.
 * Content can be a string, array, or other structure.
 */
function stringifyToolResult(content: unknown): string {
  if (typeof content === "string") return content;
  if (content === null || content === undefined) return "";
  // For arrays or objects, JSON stringify for display
  try {
    return JSON.stringify(content, null, 2);
  } catch {
    return String(content);
  }
}

/**
 * Extract tool results from content blocks.
 * Returns a map of tool_use_id → result content.
 */
function extractToolResults(
  content: string | ContentBlock[],
): Map<string, string> {
  const results = new Map<string, string>();
  if (typeof content === "string") return results;

  for (const b of content) {
    if (b.type === "tool_result" && b.tool_use_id && b.content !== undefined) {
      results.set(b.tool_use_id, stringifyToolResult(b.content));
    }
  }
  return results;
}

/**
 * Check if a user message contains only tool results (no actual user text).
 */
function isToolResultOnly(content: string | ContentBlock[]): boolean {
  if (typeof content === "string") return false;

  const hasToolResult = content.some((b) => b.type === "tool_result");
  const hasText = content.some((b) => b.type === "text" && b.text?.trim());

  return hasToolResult && !hasText;
}

/**
 * Resolve a parent reference through any skipped messages.
 * When messages are skipped (e.g., tool-result-only user messages),
 * we redirect parent references to the skipped message's parent.
 */
function resolveParent(
  parentUuid: string | null | undefined,
  skippedParents: Map<string, string | undefined>,
): string | undefined {
  if (!parentUuid) return undefined;

  // Follow the chain through any skipped messages
  const visited = new Set<string>();
  let current: string | undefined = parentUuid;
  while (current && skippedParents.has(current)) {
    if (visited.has(current)) {
      return undefined; // Cycle detected
    }
    visited.add(current);
    current = skippedParents.get(current);
  }

  return current;
}

/**
 * Transform a conversation into our intermediate format.
 */
function transformConversation(
  records: ConversationRecord[],
  sourcePath: string,
  warnings: Warning[],
  resolvedParents: Map<string, string | undefined>,
): Transcript {
  const messages: Message[] = [];
  // Track skipped message UUIDs → their resolved parent UUIDs for chain repair
  const skippedParents = new Map<string, string | undefined>();

  // Collect all tool results from user messages (tool_use_id → result)
  const allToolResults = new Map<string, string>();
  for (const rec of records) {
    if (rec.type === "user") {
      const results = extractToolResults(rec.message.content);
      for (const [id, content] of results) {
        allToolResults.set(id, content);
      }
    }
  }

  let cwd: string | undefined;

  // First pass: identify which messages will be skipped
  for (const rec of records) {
    let willSkip = false;

    // Take the first cwd we find.
    if (!cwd) {
      cwd = rec.cwd;
    }

    if (rec.type === "user") {
      if (isToolResultOnly(rec.message.content)) {
        willSkip = true;
      } else {
        const text = extractText(rec.message.content);
        if (!text.trim()) willSkip = true;
      }
    } else if (rec.type === "assistant") {
      const text = extractText(rec.message.content);
      const thinking = extractThinking(rec.message.content);
      const toolCalls = extractToolCalls(rec.message.content, allToolResults);
      // Only skip if no text, no thinking, AND no tool calls
      if (!text.trim() && !thinking && toolCalls.length === 0) {
        willSkip = true;
      }
    } else if (rec.type === "system") {
      const text = rec.content || "";
      if (!text.trim()) willSkip = true;
    }

    if (willSkip) {
      // Use the resolved parent (already walked through non-message records)
      skippedParents.set(rec.uuid, resolvedParents.get(rec.uuid));
    }
  }

  // Second pass: build messages with corrected parent references
  for (const rec of records) {
    const sourceRef = rec.uuid;
    const timestamp = rec.timestamp;
    // Start with the resolved parent (through non-message records),
    // then walk through any skipped messages
    const parentMessageRef = resolveParent(
      resolvedParents.get(rec.uuid),
      skippedParents,
    );
    const rawJson = JSON.stringify(rec);

    if (rec.type === "user") {
      // Skip tool-result-only user messages (they're just tool responses)
      if (isToolResultOnly(rec.message.content)) continue;

      const text = extractText(rec.message.content);
      if (text.trim()) {
        messages.push({
          type: "user",
          sourceRef,
          timestamp,
          parentMessageRef,
          rawJson,
          content: text,
        });
      }
    } else if (rec.type === "assistant") {
      const text = extractText(rec.message.content);
      const thinking = extractThinking(rec.message.content);
      const toolCalls = extractToolCalls(rec.message.content, allToolResults);

      // Add assistant message if there's text or thinking
      if (text.trim() || thinking) {
        messages.push({
          type: "assistant",
          sourceRef,
          timestamp,
          parentMessageRef,
          rawJson,
          content: text,
          thinking,
        });
      }

      // Add tool calls as separate group
      if (toolCalls.length > 0) {
        messages.push({
          type: "tool_calls",
          sourceRef,
          timestamp,
          parentMessageRef,
          rawJson,
          calls: toolCalls,
        });
      }
    } else if (rec.type === "system") {
      const text = rec.content || "";
      if (text.trim()) {
        messages.push({
          type: "system",
          sourceRef,
          timestamp,
          parentMessageRef,
          rawJson,
          content: text,
        });
      }
    }
  }

  // Compute time bounds from min/max across all messages (not array order,
  // which is BFS traversal order and may not be chronological for branches)
  let minTime = Infinity;
  let maxTime = -Infinity;
  for (const msg of messages) {
    const t = new Date(msg.timestamp).getTime();
    if (t < minTime) minTime = t;
    if (t > maxTime) maxTime = t;
  }
  const now = new Date().toISOString();
  const startTime = Number.isFinite(minTime)
    ? new Date(minTime).toISOString()
    : now;
  const endTime = Number.isFinite(maxTime)
    ? new Date(maxTime).toISOString()
    : startTime;

  return {
    source: {
      file: sourcePath,
      adapter: "claude-code",
    },
    metadata: {
      warnings,
      messageCount: messages.length,
      startTime,
      endTime,
      cwd,
    },
    messages,
  };
}

/**
 * Discover sessions from sessions-index.json.
 * Returns undefined if index doesn't exist or is invalid.
 */
async function discoverFromIndex(
  source: string,
): Promise<DiscoveredSession[] | undefined> {
  const indexPath = join(source, "sessions-index.json");

  try {
    const content = await Bun.file(indexPath).text();
    const index: SessionsIndex = JSON.parse(content);

    if (index.version !== 1 || !Array.isArray(index.entries)) {
      return undefined;
    }

    const sessions: DiscoveredSession[] = [];

    for (const entry of index.entries) {
      // Skip sidechains (subagents)
      if (entry.isSidechain) continue;

      // Verify the file exists and get current mtime
      try {
        const fileStat = await stat(entry.fullPath);
        sessions.push({
          path: entry.fullPath,
          relativePath:
            relative(source, entry.fullPath) || basename(entry.fullPath),
          mtime: fileStat.mtime.getTime(),
          summary: entry.summary,
        });
      } catch {
        // Skip files that no longer exist
      }
    }

    return sessions;
  } catch {
    // Index doesn't exist or is invalid
    return undefined;
  }
}

/**
 * Discover sessions via glob pattern fallback.
 */
async function discoverByGlob(source: string): Promise<DiscoveredSession[]> {
  const sessions: DiscoveredSession[] = [];
  const glob = new Glob("**/*.jsonl");

  for await (const file of glob.scan({ cwd: source, absolute: false })) {
    // Skip files in subagents directories
    if (file.includes("/subagents/")) continue;

    const fullPath = join(source, file);

    try {
      const fileStat = await stat(fullPath);
      sessions.push({
        path: fullPath,
        relativePath: file,
        mtime: fileStat.mtime.getTime(),
      });
    } catch {
      // Skip files we can't stat
    }
  }

  return sessions;
}

export const claudeCodeAdapter: Adapter = {
  name: "claude-code",
  version: "claude-code:1",
  defaultSource: process.env.CLAUDE_CONFIG_DIR || join(homedir(), ".claude"),

  async discover(source: string): Promise<DiscoveredSession[]> {
    // Try index-based discovery first, fall back to glob
    const fromIndex = await discoverFromIndex(source);
    return fromIndex ?? (await discoverByGlob(source));
  },

  parse(content: string, sourcePath: string): Transcript[] {
    const { records, warnings } = parseJsonl(content);
    const { conversations, resolvedParents } = splitConversations(records);

    if (conversations.length === 0) {
      // Return single empty transcript with warnings
      const now = new Date().toISOString();
      return [
        {
          source: { file: sourcePath, adapter: "claude-code" },
          metadata: {
            warnings,
            messageCount: 0,
            startTime: now,
            endTime: now,
            cwd: undefined,
          },
          messages: [],
        },
      ];
    }

    // For single conversation, include all warnings
    if (conversations.length === 1) {
      return [
        transformConversation(
          conversations[0],
          sourcePath,
          warnings,
          resolvedParents,
        ),
      ];
    }

    // For multiple conversations, only first gets warnings
    return conversations.map((conv, i) =>
      transformConversation(
        conv,
        sourcePath,
        i === 0 ? warnings : [],
        resolvedParents,
      ),
    );
  },
};
